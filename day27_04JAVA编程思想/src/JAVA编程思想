JAVA类的设计原则
简单工厂模式和工厂方法模式(接口)    是创建复杂对象变的简单
模版设计模式(抽象类)						不变的部分已经实现 ，变化的部分交给用户  ，继承者来实现   提供了一个模板
装饰设计模式(IO流)   						继承已有的类并在以后的方法进行增强 不断增加类的性能
单例设计模式(多线程)						保证内存中只有一个实例对象
适配器模式(GUI)			
面向对象的设计原则
1、单一性 原则     	  要保证类的单一性   设计一个学生类  那么他就不应该具备老师或者其他类的功能
2、开闭原则          	 类对扩展开放，对修改关闭            借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展的。
3、依赖注入原则      核心思想：要依赖于抽象，不要依赖于具体实现。                   其实就是说：在应用程序中，所有的类如果使用或依赖于其他的类，则应该依赖这些其他类的抽象类，
							而不是这些其他类的具体类。为了实现这一原则，就要求我们在编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。
4、接口分离原则       核心思想：不应该强迫程序依赖它们不需要使用的方法。
							其实就是说：一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。
5、迪米特原则          核心思想：一个对象应当对其他对象尽可能少的了解
其实就是说：降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用。
程序的设计模式
创建型模式（创建对象）：简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式，单例模式。(6个)
结构型模式（对象的组成）：外观模式、适配器模式、代理模式、装饰模式、桥接模式、组合模式、享元模式。(7个)
行为型模式（对象的功能）：模版方法模式、观察者模式、状态模式、职责链模式、命令模式、访问者模式、策略模式、备忘录模式、迭代器模式、解释器模式。(10个)


简单工厂模式： 平时我们创建对象的时候都是直接new,但是有的对象创建起来比较复杂，而且可以根据你的要求创建不同的对象。这样就最好创建一个工厂来帮我们造对象。
					例如： android中的位图工厂BitmapFactory.createBitmap(..... , Options)来帮我们造一个Bitmap对象,这就是工厂设计模式。
					简单工厂模式概述
					又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例
					优点
					客户端不需要在负责对象的创建，从而明确了各个类的职责
					缺点
					这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护
动物抽象类：public abstract Animal { public abstract void eat(); }
具体狗类：public class Dog extends Animal {}
具体猫类：public class Cat extends Animal {}
开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。
public class AnimalFactory {
	private AnimalFactory(){}

	//public static Dog createDog() {return new Dog();}
	//public static Cat createCat() {return new Cat();}

	//改进
	public static Animal createAnimal(String animalName) {
		if(“dog”.equals(animalName)) {}
		else if(“cat”.equals(animale)) {

		}else {
			return null;
		}
	}
} 
					
工厂方法模式概述:
工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。
优点
客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性
缺点
需要额外的编写代码，增加了工作量					
动物抽象类：public abstract Animal { public abstract void eat(); }
工厂接口：public interface Factory {public abstract Animal createAnimal();}
具体狗类：public class Dog extends Animal {}
具体猫类：public class Cat extends Animal {}
开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。
狗工厂：public class DogFactory implements Factory {
	public Animal createAnimal() {…}
        }
猫工厂：public class CatFactory implements Factory {
	public Animal createAnimal() {…}
        }
					
					

					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					